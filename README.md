# ADVENT OF CODE 2022
My solutions using scala3, with some coding rules :
- no side effects,
- no mutable data structure,
- readable, maintainable and easily understandable,

Solutions :
- [day01](src/test/scala/day01/Puzzle.scala) - ok
- [day02](src/test/scala/day02/Puzzle.scala) - ok
- [day03](src/test/scala/day03/Puzzle.scala) - ok
- [day04](src/test/scala/day04/Puzzle.scala) - ok - ranges
- [day05](src/test/scala/day05/Puzzle.scala) - ok - but readability could be enhanced
- [day06](src/test/scala/day06/Puzzle.scala) - ok
- [day07](src/test/scala/day07/Puzzle.scala) - ok - Refactored to generalize my own paths/tree conversion functions for reuse purposes  
- [day08](src/test/scala/day08/Puzzle.scala) - ok
- [day09](src/test/scala/day09/Puzzle.scala) - ok
- [day10](src/test/scala/day10/Puzzle.scala) - ok - using ZStream
- [day11](src/test/scala/day11/Puzzle.scala) - ok
- [day12](src/test/scala/day12/Puzzle.scala) - ok - Refactored to generalize shortestPath algorithm - TODO try Dijkstra
- [day13](src/test/scala/day13/Puzzle.scala) - ok - using parser combinator :) good reminder
- [day14](src/test/scala/day14/Puzzle.scala) - ok
- [day15](src/test/scala/day15/Puzzle.scala) - ok - ranges - requires some cleanup/refactoring - ranges functions can be generalized
